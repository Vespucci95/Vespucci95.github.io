{"componentChunkName":"component---src-templates-post-template-tsx","path":"/posts/reactnative-masonry-list-improvement-review/","result":{"data":{"giscus":{"siteMetadata":{"giscus":{"id":"comments","repo":"Vespucci95/Vespucci95.github.io","repoId":"R_kgDOLf3Y2Q","category":"Comments","categoryId":"DIC_kwDOLf3Y2c4CeCH6","mapping":"pathname","strict":"0","reactionsEnabled":"1","emitMetadata":"0","inputPosition":"bottom","theme":"light_tritanopia","lang":"ko"}}},"post":{"id":"d1eea6d0-b8e6-5a09-b3d7-5b4baec99ac1","html":"<p>안녕하세요.</p>\n<p>ReactNative에서 Masonry 레이아웃 페이지의 성능을 개선했던 경험을 공유드리려고 합니다.\n어떤 점들을 개선하였고, 개선하기 위해 시도했던 방법들, 그리고 느낀 점들에 대해 말씀드리겠습니다.</p>\n<h2 id=\"들어가기-전에\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%A0%84%EC%97%90\" aria-label=\"들어가기 전에 permalink\" class=\"post-toc before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>들어가기 전에</h2>\n<p>당시 요구사항은 다음과 같았습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">1. Pinterest와 같은 석조 레이아웃 (Masonry layout)\n\n2. instagram, KREAM(style)과 같은 피드 목록 페이지 (infinite scroll)</code></pre></div>\n<p>Masonry 레이아웃이란 많이 알려진 Pinterest 페이지와 같은 석조 레이아웃을 의미합니다.</p>\n<p><a href=\"https://apps.apple.com/kr/app/cate-%EC%BC%80%EC%9D%B4%ED%8A%B8/id6444556711\" target=\"_blank\" rel=\"nofollow\">CATE</a> 앱은 아트 플랫폼으로써 피드(feed)라는 소통 공간이 필요하였습니다.\n아직 앱이 준비되기 이전이었기 때문에 새롭게 만들어야 했습니다.</p>\n<p>저는 최종적으로 위의 요구사항을 지키면서 피드 성능 개선을 위해 <strong>총 6번의 전환 과정</strong>을 시도하였는데요.\n제가 시도했던 방법들을 간략하게 말씀드리도록 하겠습니다.</p>\n<p>모든 과정이 한 번에 이루어진 것은 아니며, 계속 디벨롭해 나가며 진행되었다는 점을 미리 말씀드릴게요!</p>\n<h2 id=\"첫-번째-시도\" style=\"position:relative;\"><a href=\"#%EC%B2%AB-%EB%B2%88%EC%A7%B8-%EC%8B%9C%EB%8F%84\" aria-label=\"첫 번째 시도 permalink\" class=\"post-toc before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>첫 번째 시도</h2>\n<p>첫 번째 요구사항에 맞추어 #ReactNative 에서 활용할 수 있는 모든 라이브러리를 찾아보기 시작했습니다.</p>\n<p>가장 요구사항에 적합한 라이브러리 <a href=\"https://github.com/hyochan/react-native-masonry-list\" target=\"_blank\" rel=\"nofollow\">react-native-masonry-list</a> 를 활용하고자 하였습니다.\n검토 당시 아쉽게도 사용 당시 몇 가지 문제점이 있었는데요.</p>\n<p>목록이 쌓일수록 높이 값을 계산하지 못해 우측에만 쌓이는 현상이 존재하였습니다. <a href=\"https://github.com/hyochan/react-native-masonry-list/issues/16\" target=\"_blank\" rel=\"nofollow\">issue</a></p>\n<p>실무에 적용하기에는 어렵다고 생각되었고 다른 방법을 모색하게 됩니다.</p>\n<h2 id=\"두-번째-시도\" style=\"position:relative;\"><a href=\"#%EB%91%90-%EB%B2%88%EC%A7%B8-%EC%8B%9C%EB%8F%84\" aria-label=\"두 번째 시도 permalink\" class=\"post-toc before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>두 번째 시도</h2>\n<p>기존에 시도하였던 react-native-masonry-list 구현 방식을 참고하여 ScrollView 를 이용한 석조형 레이아웃을 <strong>직접 구현</strong>하기로 합니다.</p>\n<p>react-native-masonry-list 또한 <a href=\"https://github.com/hyochan/react-native-masonry-list/blob/main/index.tsx\" target=\"_blank\" rel=\"nofollow\">ScrollView로 구현</a>되어있어 적합한 방법이라고 생각하였습니다.\n우측에 쌓이는 현상만 해결하면 사용 가능해 보였기 때문입니다.</p>\n<p>구현 방식은 colum 수에 따라 데이터를 나누어서 레이아웃을 나누어 화면에 그려주었습니다.</p>\n<p>최종적으로 우측에 쌓이는 현상을 해결하였지만, 한 가지 큰 문제점이 존재하였는데요.</p>\n<p>ScrollView는 모든 요소를 한 번에 #렌더링 하기 때문에 대용량의 데이터를 처리하기에는 옳지 않은 방법이었습니다.</p>\n<p>테스트 단계에서는 적은 양의 데이터를 처리했기 때문에 큰 이슈가 발생하지 않는 것처럼 보였는데요.\niOS 환경에서의 퍼포먼스는 준수 한 편이었지만, Android 환경에서 점차 문제가 생기기 시작했습니다.</p>\n<p>이 또한 실무에 적용하기에 어렵다고 생각되었고 다른 방법을 모색하게 되었습니다.</p>\n<h2 id=\"세-번째-시도\" style=\"position:relative;\"><a href=\"#%EC%84%B8-%EB%B2%88%EC%A7%B8-%EC%8B%9C%EB%8F%84\" aria-label=\"세 번째 시도 permalink\" class=\"post-toc before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세 번째 시도</h2>\n<p>기존에 작업되어 있던 <strong>ScrollView를 FlatList로 전환</strong>을 시도하였습니다.</p>\n<p>FlatList는 많은 양의 데이터를 처리하기에 적합하기에 꼭 필요한 과정이었습니다.</p>\n<p>그렇다면 FlatList를 이용하여 어떻게 Masonry 레이아웃을 구현할 수 있을까요?</p>\n<p>우선 column을 나누어 렌더링 하려면 <code class=\"language-text\">numColumns</code> 을 이용하면 됩니다.</p>\n<p>이후 저는 <code class=\"language-text\">postion:'absolute'</code> 를 활용하여 Pinterest 와 같은 레이아웃을 그려주는 방법으로 시도하였는데요.</p>\n<p>이 또한 다른 문제점을 맞닥뜨리게 됩니다. <code class=\"language-text\">onEndReached</code> 를 통해 다음 데이터를 불러오게 되면서 레이아웃이 무너지는 현상이 발생하였고 사용하기에는 불가능하다고 판단되었습니다.</p>\n<h2 id=\"네-번째-시도\" style=\"position:relative;\"><a href=\"#%EB%84%A4-%EB%B2%88%EC%A7%B8-%EC%8B%9C%EB%8F%84\" aria-label=\"네 번째 시도 permalink\" class=\"post-toc before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>네 번째 시도</h2>\n<p><code class=\"language-text\">numColumns</code> 와 <code class=\"language-text\">postion:'absolute'</code> 를 활용한 방법을 버리고 <code class=\"language-text\">CellRendererComponent</code> 활용한 석조 레이아웃을 구현하기로 합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 728px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/518c71dff7b54ffbb0c4b96434720e8c/0b3a5/cate-feed-01.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 216.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,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'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/518c71dff7b54ffbb0c4b96434720e8c/a59e9/cate-feed-01.webp 192w,\n/static/518c71dff7b54ffbb0c4b96434720e8c/0ca9f/cate-feed-01.webp 384w,\n/static/518c71dff7b54ffbb0c4b96434720e8c/0692d/cate-feed-01.webp 728w\"\n              sizes=\"(max-width: 728px) 100vw, 728px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/518c71dff7b54ffbb0c4b96434720e8c/3b721/cate-feed-01.png 192w,\n/static/518c71dff7b54ffbb0c4b96434720e8c/66595/cate-feed-01.png 384w,\n/static/518c71dff7b54ffbb0c4b96434720e8c/0b3a5/cate-feed-01.png 728w\"\n            sizes=\"(max-width: 728px) 100vw, 728px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/518c71dff7b54ffbb0c4b96434720e8c/0b3a5/cate-feed-01.png\"\n            alt=\"cate feed 01\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>column 수에 맞추어 영역을 구분해 주게 되면 위와 같은 모습을 띄우게 됩니다.</p>\n<p>이후 CellRendererComponent를 활용한 위치 계산식을 추가하여 영역을 재설정 해주었는데요.</p>\n<p>아쉽게도 또 다시 문제점들이 발생되었습니다.</p>\n<p><img src=\"/b0b684b929f7b182fc4e81aab18652cb/cate-feed-02.gif\" alt=\"\"></p>\n<p>목록이 쌓일 수록 스크롤이 떨리는 현상이 발생하고 스크롤 위치가 변경되는 이슈였습니다.</p>\n<p>(영상 마지막 부분을 보면 떨림 현상이 존재한다. 😭)</p>\n<h2 id=\"다섯-번째-시도\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EC%84%AF-%EB%B2%88%EC%A7%B8-%EC%8B%9C%EB%8F%84\" aria-label=\"다섯 번째 시도 permalink\" class=\"post-toc before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다섯 번째 시도</h2>\n<p><code class=\"language-text\">CellRendererComponent</code> 를 제거하고 위치 계산식을 개선하였습니다.</p>\n<p>이후 Scroll 위치가 변동되는 이슈는 사라지게 되었습니다.</p>\n<p>당시 테스트 기기 중 하나인 Android S9 에서 많은 양의 데이터를 처리할 때 스크롤을 내릴 수 조차 없었으나, 로딩이 있긴 하나 페이지를 내릴 수 있는 정도가 까지 개선되었는데요.</p>\n<p>어느 정도 사용 할 정도가 되었으니 모든 최적화 방법을 검토하고 적용해 보자 생각하였습니다.</p>\n<p>이후 FlatList 내 최적화 옵션들을 적용하였습니다.</p>\n<ul>\n<li>\n<p>keyExtractor</p>\n</li>\n<li>\n<p>getItemLayout</p>\n</li>\n<li>\n<p>windowSize</p>\n</li>\n<li>\n<p>MaxtoRenderPerBatch</p>\n</li>\n<li>\n<p>initialNumToRender</p>\n</li>\n<li>\n<p>removeClippedSubviews</p>\n</li>\n</ul>\n<p>또한 이미지 위주로 화면을 그려주기 때문에 <a href=\"https://github.com/DylanVann/react-native-fast-image\" target=\"_blank\" rel=\"nofollow\">raect-native-fast-image</a>를 적극적으로 활용하였습니다.\n적용 후 눈에 띄게 개선되었지만 초기 렌더링 속도가 아직 10s 이상 지연되었습니다.</p>\n<p>심적으로 많은 좌절감을 가지기도 하였으나, 처음으로 다시 돌아가 다른 방법들을 모색하기로 하였습니다.</p>\n<p>이후 찾게 된 신생 라이브러리 <a href=\"https://www.npmjs.com/package/@shopify/flash-list\" target=\"_blank\" rel=\"nofollow\">FlashList</a> 를 찾게 됩니다.</p>\n<h2 id=\"여섯-번째-시도\" style=\"position:relative;\"><a href=\"#%EC%97%AC%EC%84%AF-%EB%B2%88%EC%A7%B8-%EC%8B%9C%EB%8F%84\" aria-label=\"여섯 번째 시도 permalink\" class=\"post-toc before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>여섯 번째 시도</h2>\n<p>FlatList 에서 FlashList 로 전환 작업을 진행하였습니다.</p>\n<p>FlatList 성능의 UI thread <strong>5배</strong> JS thread <strong>10배</strong>의 퍼포먼스를 지닌 라이브러리 였습니다.</p>\n<p>석조 레이아웃 ( 두줄보기 )</p>\n<ul>\n<li>FlatList 에서 좌/우 높이 계산식을 통한 UI 배치 방법에서 FlashList 에서 제공하는 MasonryFlashList 로 전환</li>\n<li>높이 계산식 제거함으로써 계산 과정이 생략되었습니다.</li>\n</ul>\n<p>기본 레이아웃 ( 한줄보기 )</p>\n<ul>\n<li>FlatList -> FlashList 로 전환</li>\n</ul>\n<p>전환 작업 이후 약 10s 정도의 렌더링 속도에서 1~2s 로 대폭 감소되었습니다. 눈에 띄는 변화였는데요.</p>\n<p>FlashList 의 성능을 최대로 활용하기 위해서는 컴포넌트 내부의 useState 의 사용을 지양 했어야 했습니다. <a href=\"https://shopify.github.io/flash-list/docs/recycling\" target=\"_blank\" rel=\"nofollow\">FlashList Recycling</a></p>\n<p>최종적으로 이를 위한 리팩터링을 진행하였습니다.</p>\n<p>리팩터링 기간 동안 백엔드 팀에서는 Image resize 작업을 같이 진행해 주셨습니다.(감사합니다 🙇🏻)</p>\n<p>기존의 렌더링 할 Item 내에 state 가 존재하였고, 하나의 컴포넌트에 모든 처리 과정이 담겨있었습니다.</p>\n<ol>\n<li>\n<p>FlashList 내에서 state 를 제어하기 위한 불필요한 코드들</p>\n</li>\n<li>\n<p>UI / UX 로직</p>\n</li>\n<li>\n<p>비즈니스 로직</p>\n</li>\n</ol>\n<p>이를 위해 리 팩터링 목표를 크게 다음과 같이 선정하였습니다.</p>\n<ol>\n<li>\n<p>컴포넌트 세분화</p>\n</li>\n<li>\n<p>컴포넌트 내 State 제거</p>\n</li>\n</ol>\n<p>작업에 앞서 각각 역할에 대해 다시 한번 검토를 진행하였습니다.</p>\n<p>최종적으로 기존의 집중되어 있던 하나의 컴포넌트에서 총 20개의 컴포넌트로 분리되었습니다.</p>\n<ul>\n<li>\n<p>Atomic Design Pattern 을 적용하여 총 20개의 Atom 컴포넌트로 리 팩터링 하여 컴포넌트 간 의존 관계를 제거하였습니다.</p>\n</li>\n<li>\n<p>분리한 컴포넌트의 추상화 수준을 변경하여 선언적 프로그래밍이 가능하도록 변경되었습니다.</p>\n</li>\n<li>\n<p>피드와 연관된 컴포넌트를 Compound Component 로 구성하여 응집도가 높은 컴포넌트로 설계 하였습니다.</p>\n</li>\n<li>\n<p>비즈니스 로직의 경우 부모 페이지에서 역할을 수행할 수 있도록 변경하여 모든 의사결정을 컴포넌트를 할당한 위치에서 제어할 수 있게 되었습니다.</p>\n</li>\n<li>\n<p>메모리 절약</p>\n</li>\n<li>\n<p>컴포넌트 내 모든 addEventlistener 를 제거하고 최상위 요소에 이벤트를 위임하였습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">( n 개의 피드 수에 따라 n 개의 Event 가 할당되고 있었다. )</code></pre></div>\n</li>\n<li>\n<p>Redux 에서 유저정보를 조회해서 피드 작성 유저와 비교하는 로직</p>\n</li>\n</ul>\n<p>모든 리팩터링을 진행한 후에 <a href=\"https://fbflipper.com/\" target=\"_blank\" rel=\"nofollow\">Flipper</a> Profiler 로 측정한 결과</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 197px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3ac643b8d949db443f9e3328dfd15c11/fab3c/cate-feed-03.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 82.8125%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAABFklEQVR42u2MvUrDYBiFv0txE4kFnfRSnGocLN6KFNwURVfBQYr/CC3oYNOfxCStTRpKraKoyVSdbC3NY/O1DlYFQcceeDjnPbwcUX9skLXyaHYB3TG59Gx010Qr6RhVi2Kl71atTK5UHPwZOLcehmtxrmcpOBZa2cCqO4j7XBInNUcpFcfdV6kd97k5XcA9UKnszdPo5Y/eO1Ixd+N4hyrXJyrP2QQvWoLmxaJEPGWWyK+MkV6ewFhVMNcUnM0YDzvTMke4WzHZ3W1PYa8rnCXHudqYlF03PQOZiFnpIuw04c3vEdBt+YQ9aAfSw1Yg++iOPGz7EjqDO/p5/YwIgWG+U/hDHpb4Ovc3BP+s0eBocDT4m8F3zPEOulFhGMoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/3ac643b8d949db443f9e3328dfd15c11/a59e9/cate-feed-03.webp 192w,\n/static/3ac643b8d949db443f9e3328dfd15c11/41ef6/cate-feed-03.webp 197w\"\n              sizes=\"(max-width: 197px) 100vw, 197px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/3ac643b8d949db443f9e3328dfd15c11/3b721/cate-feed-03.png 192w,\n/static/3ac643b8d949db443f9e3328dfd15c11/fab3c/cate-feed-03.png 197w\"\n            sizes=\"(max-width: 197px) 100vw, 197px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/3ac643b8d949db443f9e3328dfd15c11/fab3c/cate-feed-03.png\"\n            alt=\"cate feed 03\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>최종적으로 10s 정도의 렌더링이 3.8ms 로 개선되었고 안드로이드 환경에서도 문제없이 작동하였습니다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"post-toc before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치며</h2>\n<p>적어놓고 보니 긴 삽질 과정을 늘어놓은 것 같네요. 하지만 과정 속에 계속해서 여러 이슈들과 부딪히면서 ReactNative에 대해 더 알게 되고 성장할 수 있었던 시간이었습니다. 때로는 한 가지 생각에 갇혀있기보다는 처음으로 다시 돌아가서 생각해 보는 것도 문제를 해결하는 하나의 방법인 것 같습니다.</p>\n<p>추가로 팀원들과 이슈를 공유하면서 FE/BE 모두 더 나은 서비스로 발전시킬 수 있었던 소중한 경험이었습니다.</p>\n<p>FlashList 적용을 고려하시는 분들께 약간의 도움이 되었길 바라면서 마치도록 하겠습니다.</p>\n<p>감사합니다.</p>","rawMarkdownBody":"안녕하세요.\n\nReactNative에서 Masonry 레이아웃 페이지의 성능을 개선했던 경험을 공유드리려고 합니다.\n어떤 점들을 개선하였고, 개선하기 위해 시도했던 방법들, 그리고 느낀 점들에 대해 말씀드리겠습니다.\n\n## 들어가기 전에\n\n당시 요구사항은 다음과 같았습니다.\n\n```txt\n1. Pinterest와 같은 석조 레이아웃 (Masonry layout)\n\n2. instagram, KREAM(style)과 같은 피드 목록 페이지 (infinite scroll)\n```\n\nMasonry 레이아웃이란 많이 알려진 Pinterest 페이지와 같은 석조 레이아웃을 의미합니다.\n\n[CATE](https://apps.apple.com/kr/app/cate-%EC%BC%80%EC%9D%B4%ED%8A%B8/id6444556711) 앱은 아트 플랫폼으로써 피드(feed)라는 소통 공간이 필요하였습니다.\n아직 앱이 준비되기 이전이었기 때문에 새롭게 만들어야 했습니다.\n\n저는 최종적으로 위의 요구사항을 지키면서 피드 성능 개선을 위해 **총 6번의 전환 과정**을 시도하였는데요.\n제가 시도했던 방법들을 간략하게 말씀드리도록 하겠습니다.\n\n모든 과정이 한 번에 이루어진 것은 아니며, 계속 디벨롭해 나가며 진행되었다는 점을 미리 말씀드릴게요!\n\n## 첫 번째 시도\n\n첫 번째 요구사항에 맞추어 #ReactNative 에서 활용할 수 있는 모든 라이브러리를 찾아보기 시작했습니다.\n\n가장 요구사항에 적합한 라이브러리 [react-native-masonry-list](https://github.com/hyochan/react-native-masonry-list) 를 활용하고자 하였습니다.\n검토 당시 아쉽게도 사용 당시 몇 가지 문제점이 있었는데요.\n\n목록이 쌓일수록 높이 값을 계산하지 못해 우측에만 쌓이는 현상이 존재하였습니다. [issue](https://github.com/hyochan/react-native-masonry-list/issues/16)\n\n실무에 적용하기에는 어렵다고 생각되었고 다른 방법을 모색하게 됩니다.\n\n## 두 번째 시도\n\n기존에 시도하였던 react-native-masonry-list 구현 방식을 참고하여 ScrollView 를 이용한 석조형 레이아웃을 **직접 구현**하기로 합니다.\n\nreact-native-masonry-list 또한 [ScrollView로 구현](https://github.com/hyochan/react-native-masonry-list/blob/main/index.tsx)되어있어 적합한 방법이라고 생각하였습니다.\n우측에 쌓이는 현상만 해결하면 사용 가능해 보였기 때문입니다.\n\n구현 방식은 colum 수에 따라 데이터를 나누어서 레이아웃을 나누어 화면에 그려주었습니다.\n\n최종적으로 우측에 쌓이는 현상을 해결하였지만, 한 가지 큰 문제점이 존재하였는데요.\n\nScrollView는 모든 요소를 한 번에 #렌더링 하기 때문에 대용량의 데이터를 처리하기에는 옳지 않은 방법이었습니다.\n\n테스트 단계에서는 적은 양의 데이터를 처리했기 때문에 큰 이슈가 발생하지 않는 것처럼 보였는데요.\niOS 환경에서의 퍼포먼스는 준수 한 편이었지만, Android 환경에서 점차 문제가 생기기 시작했습니다.\n\n이 또한 실무에 적용하기에 어렵다고 생각되었고 다른 방법을 모색하게 되었습니다.\n\n## 세 번째 시도\n\n기존에 작업되어 있던 **ScrollView를 FlatList로 전환**을 시도하였습니다.\n\nFlatList는 많은 양의 데이터를 처리하기에 적합하기에 꼭 필요한 과정이었습니다.\n\n그렇다면 FlatList를 이용하여 어떻게 Masonry 레이아웃을 구현할 수 있을까요?\n\n우선 column을 나누어 렌더링 하려면 `numColumns` 을 이용하면 됩니다.\n\n이후 저는 `postion:'absolute'` 를 활용하여 Pinterest 와 같은 레이아웃을 그려주는 방법으로 시도하였는데요.\n\n이 또한 다른 문제점을 맞닥뜨리게 됩니다. `onEndReached` 를 통해 다음 데이터를 불러오게 되면서 레이아웃이 무너지는 현상이 발생하였고 사용하기에는 불가능하다고 판단되었습니다.\n\n## 네 번째 시도\n\n`numColumns` 와 `postion:'absolute'` 를 활용한 방법을 버리고 `CellRendererComponent` 활용한 석조 레이아웃을 구현하기로 합니다.\n\n![](../media/cate-feed-01.png)\n\ncolumn 수에 맞추어 영역을 구분해 주게 되면 위와 같은 모습을 띄우게 됩니다.\n\n이후 CellRendererComponent를 활용한 위치 계산식을 추가하여 영역을 재설정 해주었는데요.\n\n아쉽게도 또 다시 문제점들이 발생되었습니다.\n\n![](../media/cate-feed-02.gif)\n\n목록이 쌓일 수록 스크롤이 떨리는 현상이 발생하고 스크롤 위치가 변경되는 이슈였습니다.\n\n(영상 마지막 부분을 보면 떨림 현상이 존재한다. 😭)\n\n## 다섯 번째 시도\n\n`CellRendererComponent` 를 제거하고 위치 계산식을 개선하였습니다.\n\n이후 Scroll 위치가 변동되는 이슈는 사라지게 되었습니다.\n\n당시 테스트 기기 중 하나인 Android S9 에서 많은 양의 데이터를 처리할 때 스크롤을 내릴 수 조차 없었으나, 로딩이 있긴 하나 페이지를 내릴 수 있는 정도가 까지 개선되었는데요.\n\n어느 정도 사용 할 정도가 되었으니 모든 최적화 방법을 검토하고 적용해 보자 생각하였습니다.\n\n이후 FlatList 내 최적화 옵션들을 적용하였습니다.\n\n- keyExtractor\n\n- getItemLayout\n\n- windowSize\n\n- MaxtoRenderPerBatch\n\n- initialNumToRender\n\n- removeClippedSubviews\n\n또한 이미지 위주로 화면을 그려주기 때문에 [raect-native-fast-image](https://github.com/DylanVann/react-native-fast-image)를 적극적으로 활용하였습니다.\n적용 후 눈에 띄게 개선되었지만 초기 렌더링 속도가 아직 10s 이상 지연되었습니다.\n\n심적으로 많은 좌절감을 가지기도 하였으나, 처음으로 다시 돌아가 다른 방법들을 모색하기로 하였습니다.\n\n이후 찾게 된 신생 라이브러리 [FlashList](https://www.npmjs.com/package/@shopify/flash-list) 를 찾게 됩니다.\n\n## 여섯 번째 시도\n\nFlatList 에서 FlashList 로 전환 작업을 진행하였습니다.\n\nFlatList 성능의 UI thread **5배** JS thread **10배**의 퍼포먼스를 지닌 라이브러리 였습니다.\n\n석조 레이아웃 ( 두줄보기 )\n\n- FlatList 에서 좌/우 높이 계산식을 통한 UI 배치 방법에서 FlashList 에서 제공하는 MasonryFlashList 로 전환\n- 높이 계산식 제거함으로써 계산 과정이 생략되었습니다.\n\n기본 레이아웃 ( 한줄보기 )\n- FlatList -> FlashList 로 전환\n\n\n전환 작업 이후 약 10s 정도의 렌더링 속도에서 1~2s 로 대폭 감소되었습니다. 눈에 띄는 변화였는데요.\n\nFlashList 의 성능을 최대로 활용하기 위해서는 컴포넌트 내부의 useState 의 사용을 지양 했어야 했습니다. [FlashList Recycling](https://shopify.github.io/flash-list/docs/recycling)\n\n최종적으로 이를 위한 리팩터링을 진행하였습니다.\n\n리팩터링 기간 동안 백엔드 팀에서는 Image resize 작업을 같이 진행해 주셨습니다.(감사합니다 🙇🏻)\n\n기존의 렌더링 할 Item 내에 state 가 존재하였고, 하나의 컴포넌트에 모든 처리 과정이 담겨있었습니다.\n\n1. FlashList 내에서 state 를 제어하기 위한 불필요한 코드들\n\n2. UI / UX 로직\n\n3. 비즈니스 로직\n\n이를 위해 리 팩터링 목표를 크게 다음과 같이 선정하였습니다.\n\n1. 컴포넌트 세분화\n\n2. 컴포넌트 내 State 제거\n\n작업에 앞서 각각 역할에 대해 다시 한번 검토를 진행하였습니다.\n\n최종적으로 기존의 집중되어 있던 하나의 컴포넌트에서 총 20개의 컴포넌트로 분리되었습니다.\n\n- Atomic Design Pattern 을 적용하여 총 20개의 Atom 컴포넌트로 리 팩터링 하여 컴포넌트 간 의존 관계를 제거하였습니다.\n\n- 분리한 컴포넌트의 추상화 수준을 변경하여 선언적 프로그래밍이 가능하도록 변경되었습니다.\n\n- 피드와 연관된 컴포넌트를 Compound Component 로 구성하여 응집도가 높은 컴포넌트로 설계 하였습니다.\n\n- 비즈니스 로직의 경우 부모 페이지에서 역할을 수행할 수 있도록 변경하여 모든 의사결정을 컴포넌트를 할당한 위치에서 제어할 수 있게 되었습니다.\n\n- 메모리 절약\n\n- 컴포넌트 내 모든 addEventlistener 를 제거하고 최상위 요소에 이벤트를 위임하였습니다.\n\n      ( n 개의 피드 수에 따라 n 개의 Event 가 할당되고 있었다. )\n\n- Redux 에서 유저정보를 조회해서 피드 작성 유저와 비교하는 로직\n\n모든 리팩터링을 진행한 후에 [Flipper](https://fbflipper.com/) Profiler 로 측정한 결과\n\n![](../media/cate-feed-03.png)\n\n최종적으로 10s 정도의 렌더링이 3.8ms 로 개선되었고 안드로이드 환경에서도 문제없이 작동하였습니다.\n\n## 마치며\n\n적어놓고 보니 긴 삽질 과정을 늘어놓은 것 같네요. 하지만 과정 속에 계속해서 여러 이슈들과 부딪히면서 ReactNative에 대해 더 알게 되고 성장할 수 있었던 시간이었습니다. 때로는 한 가지 생각에 갇혀있기보다는 처음으로 다시 돌아가서 생각해 보는 것도 문제를 해결하는 하나의 방법인 것 같습니다.\n\n추가로 팀원들과 이슈를 공유하면서 FE/BE 모두 더 나은 서비스로 발전시킬 수 있었던 소중한 경험이었습니다.\n\nFlashList 적용을 고려하시는 분들께 약간의 도움이 되었길 바라면서 마치도록 하겠습니다.\n\n감사합니다.\n","frontmatter":{"date":"2023.07.27","title":"ReactNative 피드 목록 성능 개선 후기","stage":"main","categories":"ReactNative","description":"Masonry 레이아웃 성능 개선한 내용입니다.","thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#282828","images":{"fallback":{"src":"/static/834b1ef3144d21298d99dbc92f577594/62c00/brick.png","srcSet":"/static/834b1ef3144d21298d99dbc92f577594/1b66b/brick.png 163w,\n/static/834b1ef3144d21298d99dbc92f577594/29ec6/brick.png 325w,\n/static/834b1ef3144d21298d99dbc92f577594/62c00/brick.png 650w","sizes":"(min-width: 650px) 650px, 100vw"},"sources":[{"srcSet":"/static/834b1ef3144d21298d99dbc92f577594/d1d55/brick.webp 163w,\n/static/834b1ef3144d21298d99dbc92f577594/fd7e7/brick.webp 325w,\n/static/834b1ef3144d21298d99dbc92f577594/3ff88/brick.webp 650w","type":"image/webp","sizes":"(min-width: 650px) 650px, 100vw"}]},"width":800,"height":443.0769230769231}},"publicURL":"/static/834b1ef3144d21298d99dbc92f577594/brick.png"}},"fields":{"slug":"/posts/reactnative-masonry-list-improvement-review","hashTag":["#ReactNative","#렌더링"]},"tableOfContents":"<ul>\n<li><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%A0%84%EC%97%90\">들어가기 전에</a></li>\n<li><a href=\"#%EC%B2%AB-%EB%B2%88%EC%A7%B8-%EC%8B%9C%EB%8F%84\">첫 번째 시도</a></li>\n<li><a href=\"#%EB%91%90-%EB%B2%88%EC%A7%B8-%EC%8B%9C%EB%8F%84\">두 번째 시도</a></li>\n<li><a href=\"#%EC%84%B8-%EB%B2%88%EC%A7%B8-%EC%8B%9C%EB%8F%84\">세 번째 시도</a></li>\n<li><a href=\"#%EB%84%A4-%EB%B2%88%EC%A7%B8-%EC%8B%9C%EB%8F%84\">네 번째 시도</a></li>\n<li><a href=\"#%EB%8B%A4%EC%84%AF-%EB%B2%88%EC%A7%B8-%EC%8B%9C%EB%8F%84\">다섯 번째 시도</a></li>\n<li><a href=\"#%EC%97%AC%EC%84%AF-%EB%B2%88%EC%A7%B8-%EC%8B%9C%EB%8F%84\">여섯 번째 시도</a></li>\n<li><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></li>\n</ul>"},"prev":{"id":"b30d83aa-05be-5cfa-86a1-4ef262f632d2","rawMarkdownBody":"\n# 마크다운 더미 텍스트 예제\n\n## 헤더(Headers)\n\n# 제목 1\n## 제목 2\n### 제목 3\n#### 제목 4\n##### 제목 5\n###### 제목 6\n\n## 강조(Emphasis)\n\n*이탤릭체* 또는 _이탤릭체_\n**굵은 글씨** 또는 __굵은 글씨__\n**_이탤릭체와 굵은 글씨_**\n\n## 목록(Lists)\n\n### 순서 없는 목록\n\n- 항목 1\n- 항목 2\n    - 하위 항목 2.1\n    - 하위 항목 2.2\n- 항목 3\n\n### 순서 있는 목록\n\n1. 항목 1\n2. 항목 2\n    1. 하위 항목 2.1\n    2. 하위 항목 2.2\n3. 항목 3\n\n## 링크(Links)\n\n[링크 텍스트](https://www.example.com)\n\n## 이미지(Images)\n\n![대체 텍스트](https://www.example.com/image.jpg)\n\n![대체 텍스트](../media/img-3.jpg)\n\n## 인용문(Blockquotes)\n\n> 이것은 인용문입니다.\n> 여러 줄에 걸쳐 작성할 수 있습니다.\n\n## 코드(Code)\n\n`인라인 코드`는 `backticks`로 감싸서 사용합니다.\n\n`code`\n\n코드 블록은 다음과 같이 사용합니다:\n\n```python\ndef hello_world():\n    print(\"Hello, World!\")\n```\n\n```typescript\ninterface Person {\n  name: string;\n  age: number;\n}\nconst theme = {};\nconst te = () => {\n  const b:Props = {\n    name: 'helo',\n    age: 12,\n  }\n}\n```\n## 수평선\n\n---\n\n## 테이블(Tables)\n\n|제목 셀1|제목 셀2|제목 셀3|제목 셀4|\n|---|---|---|---|\n|내용 1|내용 2|내용 3|내용 4|\n|내용 5|내용 6|내용 7|내용 8|\n|내용 9|내용 10|내용 11|내용 12|\n\n## 해시태그\n해시태그 #Markdown 테스트\n","frontmatter":{"date":"2024.03.16","title":"블로그 마크다운 테스트","stage":"sub","categories":"TypeScript"},"fields":{"slug":"/posts/blog-markdown"}},"next":null},"pageContext":{"title":"ReactNative 피드 목록 성능 개선 후기","slug":"/posts/reactnative-masonry-list-improvement-review","nextSlug":"","prevSlug":"/posts/blog-markdown"}},"staticQueryHashes":["2945020240"],"slicesMap":{}}